<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mehdi Allahyari, Angelina Yang">

<title>A Practical Approach to Retrieval Augmented Generation Systems - 2&nbsp; Retrieval Augmented Generation (RAG)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./03_prepare_data.html" rel="next">
<link href="./intro.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./02_rag.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Retrieval Augmented Generation (RAG)</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">A Practical Approach to Retrieval Augmented Generation Systems</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/mallahyari/chat2docs" rel="" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_rag.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Retrieval Augmented Generation (RAG)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_prepare_data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">RAG Pipeline Implementation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_advanced_rag.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">From Simple to Advanced RAG</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_observability_tools.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Observability Tools for RAG</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#the-limitation-of-generative-ai" id="toc-the-limitation-of-generative-ai" class="nav-link active" data-scroll-target="#the-limitation-of-generative-ai"><span class="header-section-number">2.1</span> The Limitation of Generative AI</a>
  <ul class="collapse">
  <li><a href="#example-transforming-customer-support-with-rag" id="toc-example-transforming-customer-support-with-rag" class="nav-link" data-scroll-target="#example-transforming-customer-support-with-rag"><span class="header-section-number">2.1.1</span> Example: Transforming Customer Support with RAG</a></li>
  <li><a href="#how-rag-transforms-customer-support" id="toc-how-rag-transforms-customer-support" class="nav-link" data-scroll-target="#how-rag-transforms-customer-support"><span class="header-section-number">2.1.2</span> How RAG Transforms Customer Support</a></li>
  </ul></li>
  <li><a href="#introducing-retrieval-augmented-generation-rag" id="toc-introducing-retrieval-augmented-generation-rag" class="nav-link" data-scroll-target="#introducing-retrieval-augmented-generation-rag"><span class="header-section-number">2.2</span> Introducing Retrieval Augmented Generation (RAG)</a>
  <ul class="collapse">
  <li><a href="#key-concepts-and-components" id="toc-key-concepts-and-components" class="nav-link" data-scroll-target="#key-concepts-and-components"><span class="header-section-number">2.2.1</span> Key Concepts and Components</a></li>
  <li><a href="#how-it-improves-question-answering" id="toc-how-it-improves-question-answering" class="nav-link" data-scroll-target="#how-it-improves-question-answering"><span class="header-section-number">2.2.2</span> How It Improves Question Answering</a></li>
  </ul></li>
  <li><a href="#rag-architecture" id="toc-rag-architecture" class="nav-link" data-scroll-target="#rag-architecture"><span class="header-section-number">2.3</span> RAG Architecture</a></li>
  <li><a href="#building-the-retrieval-system" id="toc-building-the-retrieval-system" class="nav-link" data-scroll-target="#building-the-retrieval-system"><span class="header-section-number">2.4</span> Building the Retrieval System</a>
  <ul class="collapse">
  <li><a href="#choosing-a-retrieval-model" id="toc-choosing-a-retrieval-model" class="nav-link" data-scroll-target="#choosing-a-retrieval-model"><span class="header-section-number">2.4.1</span> Choosing a Retrieval Model</a></li>
  </ul></li>
  <li><a href="#embeddings-and-vector-databases-for-retrieval-in-rag" id="toc-embeddings-and-vector-databases-for-retrieval-in-rag" class="nav-link" data-scroll-target="#embeddings-and-vector-databases-for-retrieval-in-rag"><span class="header-section-number">2.5</span> Embeddings and Vector Databases for Retrieval in RAG</a>
  <ul class="collapse">
  <li><a href="#vector-embeddings-an-overview" id="toc-vector-embeddings-an-overview" class="nav-link" data-scroll-target="#vector-embeddings-an-overview"><span class="header-section-number">2.5.1</span> Vector Embeddings: An Overview</a></li>
  <li><a href="#vector-databases-and-their-role-in-enhancing-retrieval" id="toc-vector-databases-and-their-role-in-enhancing-retrieval" class="nav-link" data-scroll-target="#vector-databases-and-their-role-in-enhancing-retrieval"><span class="header-section-number">2.5.2</span> Vector Databases and Their Role in Enhancing Retrieval</a></li>
  </ul></li>
  <li><a href="#rag-data-ingestion-pipeline" id="toc-rag-data-ingestion-pipeline" class="nav-link" data-scroll-target="#rag-data-ingestion-pipeline"><span class="header-section-number">2.6</span> RAG Data Ingestion Pipeline</a></li>
  <li><a href="#challenges-of-retrieval-augmented-generation" id="toc-challenges-of-retrieval-augmented-generation" class="nav-link" data-scroll-target="#challenges-of-retrieval-augmented-generation"><span class="header-section-number">2.7</span> Challenges of Retrieval-Augmented Generation</a>
  <ul class="collapse">
  <li><a href="#data-quality-and-relevance" id="toc-data-quality-and-relevance" class="nav-link" data-scroll-target="#data-quality-and-relevance"><span class="header-section-number">2.7.1</span> Data Quality and Relevance</a></li>
  <li><a href="#integration-complexity" id="toc-integration-complexity" class="nav-link" data-scroll-target="#integration-complexity"><span class="header-section-number">2.7.2</span> Integration Complexity</a></li>
  <li><a href="#scalability" id="toc-scalability" class="nav-link" data-scroll-target="#scalability"><span class="header-section-number">2.7.3</span> Scalability</a></li>
  <li><a href="#evaluation-metrics" id="toc-evaluation-metrics" class="nav-link" data-scroll-target="#evaluation-metrics"><span class="header-section-number">2.7.4</span> Evaluation Metrics</a></li>
  <li><a href="#domain-adaptation" id="toc-domain-adaptation" class="nav-link" data-scroll-target="#domain-adaptation"><span class="header-section-number">2.7.5</span> Domain Adaptation</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/mallahyari/chat2docs/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-two" class="quarto-section-identifier"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Retrieval Augmented Generation (RAG)</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>Generative AI, a subset of artificial intelligence, has revolutionized the field of text generation. It has paved the way for machines to generate human-like text, offering a myriad of benefits in various applications. From content creation and chatbots to language translation and natural language understanding, generative AI has proven to be a powerful tool in the world of natural language processing. However, it is essential to recognize that despite its remarkable capabilities, generative AI systems have limitations, one of which is their reliance on the data they have been trained on to generate responses.</p>
<section id="the-limitation-of-generative-ai" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="the-limitation-of-generative-ai"><span class="header-section-number">2.1</span> The Limitation of Generative AI</h2>
<p>Generative AI models, such as GPT3 (Generative Pre-trained Transformer), have been trained on vast datasets containing text from the internet. While this training process equips them with a broad understanding of language and context, it also introduces limitations. These models can only generate text that aligns with the patterns and information present in their training data. As a result, their responses may not always be accurate or contextually relevant, especially when dealing with niche topics or recent developments that may not be adequately represented in their training data.</p>
<section id="example-transforming-customer-support-with-rag" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="example-transforming-customer-support-with-rag"><span class="header-section-number">2.1.1</span> Example: Transforming Customer Support with RAG</h3>
<p>Imagine you’re the owner of a thriving e-commerce platform, selling a wide range of products from electronics to fashion. You’ve recently integrated a chatbot to assist your customers with inquiries, but you’re starting to see its limitations. Let’s explore how Retrieval-Augmented Generation (RAG) can help overcome these limitations and enhance the customer support experience.</p>
<p><strong>Limitations of a Traditional Large Language Model (LLM)</strong></p>
<p>Your existing chatbot is built around a traditional Large Language Model (LLM). While it’s knowledgeable about general product information, your customers are increasingly seeking more specific and real-time assistance. Here are some challenges you’ve encountered:</p>
<p><strong>Product Availability:</strong> Customers often inquire about the availability of specific items, especially during sales or promotions. The LLM can provide information based on its training data, but it doesn’t have access to real-time inventory data.</p>
<p><strong>Shipping and Delivery:</strong> Customers frequently ask about shipping times, tracking information, and potential delays. The LLM can provide standard shipping policies, but it can’t offer real-time updates on the status of an individual order.</p>
<p><strong>Product Reviews:</strong> Shoppers want to know about recent product reviews and ratings to make informed decisions. The LLM lacks access to the latest customer reviews and sentiment analysis.</p>
<p><strong>Promotions and Discounts:</strong> Customers seek information about ongoing promotions, discounts, and special offers. The LLM can only provide details based on the data it was trained on, missing out on time-sensitive deals.</p>
</section>
<section id="how-rag-transforms-customer-support" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="how-rag-transforms-customer-support"><span class="header-section-number">2.1.2</span> How RAG Transforms Customer Support</h3>
<p>Now, let’s introduce RAG into your e-commerce customer support system:</p>
<p>Retrieval of Real-Time Data: With RAG, your chatbot can connect to your e-commerce platform’s databases and data warehouses in real-time. It can retrieve the latest information about product availability, stock levels, and shipping status.</p>
<p><strong>Incorporating User Reviews:</strong> RAG can scrape and analyze customer reviews and ratings from your website, social media, and other sources. It can then generate responses that include recent reviews, helping customers make informed choices.</p>
<p><strong>Dynamic Promotions:</strong> RAG can access your promotion database and provide up-to-the-minute details about ongoing discounts, flash sales, and limited-time offers. It can even suggest personalized promotions based on a user’s browsing history.</p>
<p><strong>Order Tracking:</strong> RAG can query your logistics system to provide customers with real-time tracking information for their orders. It can also proactively notify customers of any delays or issues.</p>
</section>
</section>
<section id="introducing-retrieval-augmented-generation-rag" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="introducing-retrieval-augmented-generation-rag"><span class="header-section-number">2.2</span> Introducing Retrieval Augmented Generation (RAG)</h2>
<p>To address the limitation of generative AI, researchers and engineers have developed innovative approaches, one of which is the Retrieval Augmented Generation (RAG) approach. RAG initially caught the interest of generative AI developers following the release of a seminal paper titled “<em>Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks</em>” <span class="citation" data-cites="lewis2020retrieval">(<a href="references.html#ref-lewis2020retrieval" role="doc-biblioref">Lewis et al. 2020</a>)</span> at Facebook AI Research. RAG combines the strengths of generative AI with retrieval techniques to enhance the quality and relevance of generated text. Unlike traditional generative models that rely solely on their internal knowledge, RAG incorporates an additional step where it retrieves information from external sources, such as databases, documents, or the web, before generating a response. This integration of retrieval mechanisms empowers RAG to access up-to-date information and context, making it particularly valuable for applications where accurate and current information is critical.</p>
<p>In this chapter, we will delve deeper into the Retrieval Augmented Generation (RAG) approach, exploring its architecture, advantages, and real-world applications. By doing so, we will gain a better understanding of how RAG represents a significant step forward in improving the capabilities of generative AI and overcoming the limitations posed by reliance on static training data. Understanding the key concepts and components of this approach is essential for building an effective chat-to-PDF app.</p>
<section id="key-concepts-and-components" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="key-concepts-and-components"><span class="header-section-number">2.2.1</span> Key Concepts and Components</h3>
<p>To grasp the essence of Retrieval-Augmented Generation, let’s explore its key concepts and components:</p>
<ol type="1">
<li><strong>Retrieval Component:</strong> The retrieval component is responsible for searching and selecting relevant information from a database or corpus of documents. This component utilizes techniques like document indexing, query expansion, and ranking to identify the most suitable documents based on the user’s query.</li>
<li><strong>Generation Component:</strong> Once the relevant documents are retrieved, the generation component takes over. It leverages Large Language Models (LLMs) such as GPT-3 to process the retrieved information and generate coherent and contextually accurate responses. This component is responsible for converting retrieved facts into human-readable answers.</li>
<li><strong>Interaction Loop:</strong> Retrieval-Augmented Generation often involves an interaction loop between the retrieval and generation components. The initial retrieval may not always return the perfect answer, so the generation component can refine and enhance the response iteratively by referring back to the retrieval results.</li>
<li><strong>Fine-Tuning:</strong> Successful implementation of this approach often requires fine-tuning LLMs on domain-specific data. Fine-tuning adapts the model to understand and generate content relevant to the specific knowledge domain, improving the quality of responses.</li>
<li><strong>Latent Space Representations:</strong> Retrieval models often convert documents and queries into latent space representations, making it easier to compare and rank documents based on their relevance to a query. These representations are crucial for efficient retrieval.</li>
<li><strong>Attention Mechanisms:</strong> Both the retrieval and generation components typically employ attention mechanisms. Attention mechanisms help the model focus on the most relevant parts of the input documents and queries, improving the accuracy of responses.</li>
</ol>
</section>
<section id="how-it-improves-question-answering" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="how-it-improves-question-answering"><span class="header-section-number">2.2.2</span> How It Improves Question Answering</h3>
<p>The Retrieval-Augmented Generation approach offers several advantages for question answering:</p>
<ol type="1">
<li><strong>Access to a Wide Knowledge Base:</strong> By integrating retrieval, the system can access a vast knowledge base, including large document collections. This enables the model to provide answers that may not be present in its pre-training data, making it highly informative.</li>
<li><strong>Contextual Understanding:</strong> The generation component uses the context provided by the retrieval results to generate answers that are not only factually accurate but also contextually relevant. This contextual understanding leads to more coherent and precise responses.</li>
<li><strong>Iterative Refinement:</strong> The interaction loop between retrieval and generation allows the system to iteratively refine its responses. If the initial response is incomplete or incorrect, the generation component can make further inquiries or clarifications based on the retrieval results, leading to improved answers.</li>
<li><strong>Adaptability to Diverse Queries:</strong> Retrieval-Augmented Generation can handle a wide range of user queries, including complex and multi-faceted questions. It excels in scenarios where simple keyword-based search engines may fall short.</li>
<li><strong>Fine-Tuning for Specific Domains:</strong> By fine-tuning the model on domain-specific data, you can tailor it to excel in particular knowledge domains. This makes it a valuable tool for specialized question answering tasks, such as legal or medical consultations.</li>
</ol>
<p>In summary, Retrieval-Augmented Generation is a dynamic approach that combines the strengths of retrieval and generation to provide accurate, contextually relevant, and informative answers to user queries. Understanding its key components and advantages is essential as we move forward in building our chat-to-PDF app, which will leverage this approach to enhance question answering over PDF documents.</p>
</section>
</section>
<section id="rag-architecture" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="rag-architecture"><span class="header-section-number">2.3</span> RAG Architecture</h2>
<p>At its core, RAG is a framework that synergizes two vital components:</p>
<p><strong>Retrieval Model:</strong> This component specializes in searching and retrieving relevant information from extensive datasets, such as documents, articles, or databases. It identifies passages or documents that contain information related to a user’s query.</p>
<p><strong>Generation Model:</strong> On the other hand, the generation model excels in crafting coherent and contextually rich responses to user queries. It’s often based on large language models (LLMs) like GPT-3, which can generate human-like text. <a href="#fig-rag-architecture">Figure&nbsp;<span>2.1</span></a> shows the RAG architecture.</p>
<div id="fig-rag-architecture" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="diagrams/rag_architecture.png" class="img-fluid figure-img" alt="RAG architecture"></p>
<figcaption class="figure-caption">Figure&nbsp;2.1: RAG architechture</figcaption>
</figure>
</div>
</section>
<section id="building-the-retrieval-system" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="building-the-retrieval-system"><span class="header-section-number">2.4</span> Building the Retrieval System</h2>
<p>In this section, we will focus on building the retrieval system, a critical component of the chat-to-PDF app that enables the extraction of relevant information from PDF documents. This section is essential for implementing the Retrieval-Augmented Generation approach effectively.</p>
<section id="choosing-a-retrieval-model" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="choosing-a-retrieval-model"><span class="header-section-number">2.4.1</span> Choosing a Retrieval Model</h3>
<p>Choosing the right retrieval model is a crucial decision when building your chat-to-PDF app. Retrieval models determine how efficiently and accurately the system can find and rank relevant documents in response to user queries. Here are some considerations when selecting a retrieval model:</p>
<ul>
<li><strong>TF-IDF (Term Frequency-Inverse Document Frequency):</strong> TF-IDF is a classical retrieval model that calculates the importance of terms in a document relative to a corpus. It’s simple to implement and effective for certain tasks.</li>
<li><strong>BM25:</strong> BM25 is an improved version of TF-IDF that accounts for document length and term saturation. It’s often more effective in modern retrieval tasks.</li>
<li><strong>Vector Space Models:</strong> These models represent documents and queries as vectors in a high-dimensional space. Cosine similarity or other distance metrics are used to rank documents. Implementations like Latent Semantic Analysis (LSA) and Word Embeddings (e.g., Word2Vec) can be used.</li>
<li><strong>Neural Ranking Models:</strong> Modern neural models, such as BERT-based models, are increasingly popular for retrieval tasks due to their ability to capture complex semantic relationships. They can be fine-tuned for specific tasks and domains.</li>
<li><strong>Hybrid Models:</strong> Combining multiple retrieval models, such as a combination of TF-IDF and neural models, can offer the benefits of both approaches.</li>
<li><strong>Domain and Data Size:</strong> Consider the specific requirements of your chat-to-PDF app. Some retrieval models may be more suitable for small or specialized document collections, while others excel in handling large, diverse corpora.</li>
<li><strong>Scalability:</strong> Ensure that the chosen retrieval model can scale to meet the needs of your application, especially if you anticipate handling a substantial volume of PDF documents.</li>
</ul>
</section>
</section>
<section id="embeddings-and-vector-databases-for-retrieval-in-rag" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="embeddings-and-vector-databases-for-retrieval-in-rag"><span class="header-section-number">2.5</span> Embeddings and Vector Databases for Retrieval in RAG</h2>
<p>In addition to selecting an appropriate retrieval model, leveraging embeddings and vector databases can significantly enhance the performance and efficiency of the retrieval component within your chat-to-PDF app. Vector embeddings are a fundamental concept in modern information retrieval and natural language processing. They transform textual data into numerical vectors, enabling computers to understand and manipulate text data in a mathematical, geometric space. These embeddings capture semantic and contextual relationships between words, documents, or other textual entities, making them highly valuable in various applications, including the retrieval component of Retrieval Augmented Generation (RAG).</p>
<section id="vector-embeddings-an-overview" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1" class="anchored" data-anchor-id="vector-embeddings-an-overview"><span class="header-section-number">2.5.1</span> Vector Embeddings: An Overview</h3>
<p>Vector embeddings represent words, phrases, sentences, or even entire documents as points in a high-dimensional vector space. The key idea is to map each textual element into a vector in such a way that semantically similar elements are located close to each other in this space, while dissimilar elements are further apart. This geometric representation facilitates similarity calculations, clustering, and other operations.</p>
<p>Examples of Vector Embeddings:</p>
<ol type="1">
<li><strong>Word Embeddings (Word2Vec, GloVe):</strong> Word embeddings represent individual words as vectors. For example, “king” and “queen” may be represented as vectors that are close together in the vector space because they share similar semantic properties.</li>
<li><strong>Document Embeddings (Doc2Vec, BERT):</strong> Document embeddings map entire documents (such as PDFs) into vectors. Two documents discussing similar topics will have embeddings that are close in the vector space.</li>
</ol>
<p>There are abundent of tutorials and resources that can help you learn more about vector embeddings. Here are some resources that can help you get started:</p>
<ul>
<li><a href="https://weaviate.io/blog/vector-embeddings-explained">Vector Embeddings Explained</a></li>
<li><a href="https://cloud.google.com/blog/topics/developers-practitioners/meet-ais-multitool-vector-embeddings">Google Vector embeddings</a></li>
<li><a href="https://www.elastic.co/what-is/vector-embedding">What are vector embeddings</a></li>
</ul>
</section>
<section id="vector-databases-and-their-role-in-enhancing-retrieval" class="level3" data-number="2.5.2">
<h3 data-number="2.5.2" class="anchored" data-anchor-id="vector-databases-and-their-role-in-enhancing-retrieval"><span class="header-section-number">2.5.2</span> Vector Databases and Their Role in Enhancing Retrieval</h3>
<p>Vector databases, also known as similarity search engines or vector index databases, play a crucial role in the retrieval component of RAG by efficiently storing and retrieving these vector embeddings. They are specialized databases designed for retrieving vectors based on similarity, making them well-suited for scenarios where similarity between data points needs to be calculated quickly and accurately.</p>
<p>How Vector Databases Enhance Retrieval in RAG:</p>
<ol type="1">
<li><strong>Fast Retrieval:</strong> Vector databases employ indexing structures optimized for similarity search. They use algorithms like approximate nearest neighbor (ANN) search to quickly locate the most similar vectors, even in large datasets containing numerous documents.</li>
<li><strong>Scalability:</strong> Vector databases can efficiently scale as the corpus of documents grows. This ensures that retrieval performance remains consistent, regardless of the dataset’s size.</li>
<li><strong>Advanced Similarity Scoring:</strong> These databases offer a range of similarity metrics, such as cosine similarity or Jaccard index, allowing you to fine-tune the relevance ranking of retrieved documents based on your specific requirements.</li>
<li><strong>Integration with Retrieval Models:</strong> Vector databases can be seamlessly integrated into your retrieval system. They complement retrieval models like TF-IDF, BM25, or neural ranking models by providing an efficient means of candidate document selection based on vector similarity.</li>
</ol>
<p>All of these factors has resulted in numerous new vector databases. Selecting and depending on one of these databases can have long-lasting consequences and dependencies within your system. Ideally, we opt for a vector database that exhibits strong scalability, all while maintaining cost-efficiency and minimizing latency. Some of these vector databases are: <a href="https://qdrant.tech/">Qdrant</a>, <a href="https://weaviate.io/">Weaviate</a>, <a href="https://www.pinecone.io/">Pinecone</a>, <a href="https://github.com/pgvector/pgvector">pgvector</a>, <a href="https://milvus.io/">Milvus</a>, and <a href="https://www.trychroma.com/">Chroma</a>.</p>
<div id="fig-vdb-comparison" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="diagrams/ch2_vdb_comparison.png" class="img-fluid figure-img" alt="vector databases comparison"></p>
<figcaption class="figure-caption">Figure&nbsp;2.2: Vector databases comparison. <a href="https://docs.google.com/spreadsheets/d/1oAeF4Q7ILxxfInGJ8vTsBck3-2U9VV8idDf3hJOozNw/edit#gid=0">Image source</a></figcaption>
</figure>
</div>
</section>
</section>
<section id="rag-data-ingestion-pipeline" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="rag-data-ingestion-pipeline"><span class="header-section-number">2.6</span> RAG Data Ingestion Pipeline</h2>
<p>Before your Chat-to-PDF app can effectively retrieve information from a vector database, it’s imperative to preprocess the PDF documents and create a structured and searchable index for the preprocessed data. This searchable index serves as the cornerstone of your application, akin to a meticulously organized library catalog. It empowers your system to swiftly and accurately locate relevant information within PDF documents, enhancing the efficiency and precision of the retrieval process.</p>
<p><a href="#fig-rag-data-pipeline">Figure&nbsp;<span>2.3</span></a> illustrates the RAG data ingestion pipeline. in <a href="03_prepare_data.html"><span>Chapter&nbsp;3</span></a>, we will fully discuss how to prepare, index, and store the documents in a vector database.</p>
<div id="fig-rag-data-pipeline" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="diagrams/rag_data_pipeline.png" class="img-fluid figure-img" alt="RAG Data ingestion pipeline"></p>
<figcaption class="figure-caption">Figure&nbsp;2.3: RAG data ingestion pipeline</figcaption>
</figure>
</div>
</section>
<section id="challenges-of-retrieval-augmented-generation" class="level2" data-number="2.7">
<h2 data-number="2.7" class="anchored" data-anchor-id="challenges-of-retrieval-augmented-generation"><span class="header-section-number">2.7</span> Challenges of Retrieval-Augmented Generation</h2>
<p>The adoption of Retrieval-Augmented Generation (RAG) represents a significant advancement in natural language processing and information retrieval. However, like any complex AI system, RAG presents a set of challenges that must be addressed to fully harness its potential. In this section, we explore some of the key challenges associated with RAG.</p>
<section id="data-quality-and-relevance" class="level3" data-number="2.7.1">
<h3 data-number="2.7.1" class="anchored" data-anchor-id="data-quality-and-relevance"><span class="header-section-number">2.7.1</span> Data Quality and Relevance</h3>
<p>RAG heavily relies on the availability of high-quality and relevant data for both retrieval and generation tasks. Challenges in this area include:</p>
<ul>
<li><p><strong>Noisy Data:</strong> Incomplete, outdated, or inaccurate data sources can lead to retrieval of irrelevant information, impacting the quality of generated responses.</p></li>
<li><p><strong>Bias and Fairness:</strong> Biases present in training data may lead to biased retrieval and generation, perpetuating stereotypes or misinformation.</p></li>
</ul>
</section>
<section id="integration-complexity" class="level3" data-number="2.7.2">
<h3 data-number="2.7.2" class="anchored" data-anchor-id="integration-complexity"><span class="header-section-number">2.7.2</span> Integration Complexity</h3>
<p>Integrating retrieval and generation components seamlessly is non-trivial, as it involves bridging different architectures and models. Challenges include:</p>
<ul>
<li><p><strong>Model Compatibility:</strong> Ensuring that the retrieval and generation models work harmoniously, especially when combining traditional methods (e.g., TF-IDF) with neural models (e.g., GPT-3).</p></li>
<li><p><strong>Latency and Efficiency:</strong> Balancing the need for real-time responsiveness with the computational resources required for retrieval and generation.</p></li>
</ul>
</section>
<section id="scalability" class="level3" data-number="2.7.3">
<h3 data-number="2.7.3" class="anchored" data-anchor-id="scalability"><span class="header-section-number">2.7.3</span> Scalability</h3>
<p>Scaling RAG systems to handle large volumes of data and user requests can be challenging:</p>
<ul>
<li><p><strong>Indexing Efficiency:</strong> As the document corpus grows, maintaining an efficient and up-to-date index becomes crucial for retrieval speed.</p></li>
<li><p><strong>Model Scaling:</strong> Deploying large-scale neural models for both retrieval and generation may require substantial computational resources.</p></li>
</ul>
</section>
<section id="evaluation-metrics" class="level3" data-number="2.7.4">
<h3 data-number="2.7.4" class="anchored" data-anchor-id="evaluation-metrics"><span class="header-section-number">2.7.4</span> Evaluation Metrics</h3>
<p>Evaluating the performance of RAG systems presents difficulties:</p>
<ul>
<li><p><strong>Lack of Gold Standards:</strong> In some cases, there may be no clear gold standard for evaluating the relevance and quality of retrieved documents.</p></li>
<li><p><strong>Diverse User Needs:</strong> Users have diverse information needs, making it challenging to develop universal evaluation metrics.</p></li>
</ul>
</section>
<section id="domain-adaptation" class="level3" data-number="2.7.5">
<h3 data-number="2.7.5" class="anchored" data-anchor-id="domain-adaptation"><span class="header-section-number">2.7.5</span> Domain Adaptation</h3>
<p>Adapting RAG systems to specific domains or industries can be complex:</p>
<ul>
<li><p><strong>Domain-Specific Knowledge:</strong> Incorporating domain-specific knowledge and jargon into retrieval and generation.</p></li>
<li><p><strong>Training Data Availability:</strong> The availability of domain-specific training data for fine-tuning models.</p></li>
</ul>
<p>Addressing these challenges is essential to unlock the full potential of RAG in various applications, from question answering to content generation. As research and development in this field continue, finding innovative solutions to these challenges will be critical for building robust and reliable RAG systems that deliver accurate, relevant, and trustworthy information to users.</p>
<p>As we conclude our exploration of the foundations and the retrieval component of Retrieval-Augmented Generation (RAG) systems in this Chapter, we now turn our attention to the practical implementation of RAG pipelines in Chapter 3. In this next chapter, we’ll delve into the nitty-gritty details of how these systems come to life, starting with the preprocessing of PDF documents and the data ingestion pipeline. We’ll also discuss the generation components that make RAG systems work. Further, Chapter 3 explores the impact of text splitting methods on RAG quality and the crucial role of metadata in enhancing the overall RAG experience.</p>


<div id="refs" class="references csl-bib-body hanging-indent" role="list" style="display: none">
<div id="ref-lewis2020retrieval" class="csl-entry" role="listitem">
Lewis, Patrick, Ethan Perez, Aleksandra Piktus, Fabio Petroni, Vladimir Karpukhin, Naman Goyal, Heinrich Küttler, et al. 2020. <span>“Retrieval-Augmented Generation for Knowledge-Intensive Nlp Tasks.”</span> <em>Advances in Neural Information Processing Systems</em> 33: 9459–74.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./intro.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./03_prepare_data.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">RAG Pipeline Implementation</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>